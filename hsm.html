<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Hierarchical State Machine (HSM) &#8212; AMAST  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=6625fa76" />
    <link rel="stylesheet" type="text/css" href="_static/flask.css?v=b87c8d14" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script data-project="amast" data-version="" src="_static/describe_version.js?v=fa7f30d0"></script>
    <link rel="canonical" href="https://adel-mamin.github.io/amast/hsm.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Finite State Machine (FSM)" href="fsm.html" />
    <link rel="prev" title="Patterns" href="patterns/index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="fsm.html" title="Finite State Machine (FSM)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="patterns/index.html" title="Patterns"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">AMAST  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Hierarchical State Machine (HSM)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="hierarchical-state-machine-hsm">
<h1>Hierarchical State Machine (HSM)<a class="headerlink" href="#hierarchical-state-machine-hsm" title="Link to this heading">¶</a></h1>
<section id="credit">
<h2>Credit<a class="headerlink" href="#credit" title="Link to this heading">¶</a></h2>
<p>The design and implementation of the HSM library is heavily inspired by
<a class="reference external" href="https://www.state-machine.com/psicc2">Practical UML Statecharts in C/C++: Event-Driven Programming for Embedded Systems 2nd Edition</a>
by Miro Samek. Also the example HSM state diagram in <strong>hsm.png</strong> is borrowed
from the book.</p>
</section>
<section id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Link to this heading">¶</a></h2>
<blockquote>
<div><dl class="simple">
<dt>event</dt><dd><p>a unique ID plus optionally some data associated with it</p>
</dd>
<dt>entry event</dt><dd><p>an event sent to a state when the state is entered (<strong>AM_EVT_HSM_ENTRY</strong>)</p>
</dd>
<dt>exit event</dt><dd><p>an event sent to a state when the state is exited (<strong>AM_EVT_HSM_EXIT</strong>)</p>
</dd>
<dt>init event</dt><dd><p>an event sent to a target state when the state is entered
(<strong>AM_EVT_HSM_INIT</strong>). It immediately follows the entry event.</p>
</dd>
<dt>state</dt><dd><p>an event handler. A,B,C,D,E,F,am_hsm_top are all states (see state diagram below)</p>
</dd>
<dt>current state</dt><dd><p>the state which currently gets the incoming events</p>
</dd>
<dt>active state</dt><dd><p>same as current state</p>
</dd>
<dt>state transition</dt><dd><p>the process of changing of the current state to another or to itself</p>
</dd>
<dt>initial transition</dt><dd><p>the state transition that may optionally happen after entering a state
if the state is a target state of a state transition.
The state D has the initial transition, whereas state B does not.</p>
</dd>
<dt>source state</dt><dd><p>the state that initiates the state transition</p>
</dd>
<dt>target state</dt><dd><p>the destination state of a state transition</p>
</dd>
<dt>superstate</dt><dd><p>an HSM state that is a parent (ancestor) of one or more other states
(children, substates). A,B,D,am_hsm_top are all superstates.</p>
</dd>
<dt>top (super)state</dt><dd><p>the ultimate root of the state hierarchy (<strong>am_hsm_top()</strong>)</p>
</dd>
<dt>substate</dt><dd><p>a state that has a superstate as its parent (ancestor).
A state can be substate and superstate simultaneously.
A,B,C,D,E,F are all substates.</p>
</dd>
<dt>child state</dt><dd><p>same as substate</p>
</dd>
<dt>parent state</dt><dd><p>same as superstate</p>
</dd>
<dt>ancestor state</dt><dd><p>same as superstate</p>
</dd>
<dt>ancestor chain</dt><dd><p>the parent-child relation chain from a state to the top level superstate.
B-A-am_hsm_top is an ancestor chain. Same is F-am_hsm_top etc.</p>
</dd>
<dt>nearest common ancestor (NCA)</dt><dd><p>the first common ancestor in two ancestor chains.
For B-A-am_hsm_top and F-am_hsm_top the NCA is am_hsm_top.
For C-B-A-am_hsm_top and D-A-am_hsm_top the NCA is A.
For C-B-A-am_hsm_top and B-A-am_hsm_top the NCA is B.</p>
</dd>
<dt>topology</dt><dd><p>HSM topology is the architecture of HSM - the set of all parent -
child relations between HSM states</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>HSM differs from a Finite State Machine (FSM) in that a state can have a
parent state that can be used to share behavior via a mechanism similar to
inheritance - behavioral inheritance. The parent-child relationship between
states impacts both event handling and transitions.</p>
<p>The HSM is a combination of one or more state-handler functions of
type <strong>am_hsm_state_fn</strong>.</p>
</section>
<section id="example-hsm">
<h2>Example HSM<a class="headerlink" href="#example-hsm" title="Link to this heading">¶</a></h2>
<p>In order to explore how event handling and transitions work in an HSM,
consider the below state machine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+----------------------------------------------+</span>
<span class="o">|</span>                                              <span class="o">|</span>
<span class="o">|</span>                <span class="n">am_hsm_top</span>                    <span class="o">|</span>
<span class="o">|</span>      <span class="p">(</span><span class="n">HSM</span> <span class="n">top</span> <span class="n">superstate</span> <span class="n">am_hsm_top</span><span class="p">())</span>       <span class="o">|</span>
<span class="o">|</span>                                              <span class="o">|</span>
<span class="o">|</span>  <span class="o">+---------------------------------+</span>  <span class="o">+---+</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">A</span>                              <span class="o">|</span>  <span class="o">|</span> <span class="n">F</span> <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">+-----------+</span>  <span class="o">+------------+</span>  <span class="o">|</span>  <span class="o">+---+</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">B</span>        <span class="o">|</span>  <span class="o">|</span>  <span class="n">D</span>    <span class="o">*</span>    <span class="o">|</span>  <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>           <span class="o">|</span>  <span class="o">|</span>       <span class="o">|</span>    <span class="o">|</span>  <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">+-----+</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">+----</span><span class="n">v</span><span class="o">-+</span>  <span class="o">|</span>  <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">C</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>   <span class="n">E</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">+-----+</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">+------+</span>  <span class="o">|</span>  <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>           <span class="o">|</span>  <span class="o">|</span>            <span class="o">|</span>  <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">+-----------+</span>  <span class="o">+------------+</span>  <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>                                 <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>  <span class="o">+---------------------------------+</span>         <span class="o">|</span>
<span class="o">|</span>                                              <span class="o">|</span>
<span class="o">+----------------------------------------------+</span>
</pre></div>
</div>
</section>
<section id="state-relations">
<h2>State Relations<a class="headerlink" href="#state-relations" title="Link to this heading">¶</a></h2>
<p>States B and D are children of A. States C and E are children of B and D,
respectively.  State F has no children. Both A and F have the default parent
am_hsm_top provided by the library (<strong>am_hsm_top()</strong>).</p>
</section>
<section id="event-propagation">
<h2>Event Propagation<a class="headerlink" href="#event-propagation" title="Link to this heading">¶</a></h2>
<p>Events are always sent first to the active state. The active state can choose
whether to consume the event or to pass it to its parent. If the state
chooses to consume the event then event handling ends with the state. If,
however, the state chooses to pass, then the event will be sent to the state’s
parent. At this point the parent must make the same decision. Event handling
ends when the state or one of its ancestors consumes the event or the event
reaches the default superstate <strong>am_hsm_top()</strong>. The default top level
superstate <strong>am_hsm_top()</strong> always returns <strong>AM_HSM_RC_HANDLED</strong> for all events.</p>
<p>Assume that the state C shown above is active and an event is sent to the
state machine. State C will be the first state to receive this event. If it
chooses to pass then, the event will be sent to state B, its direct parent. If
state B also chooses to pass then the event will finally be sent to state
A. If A chooses to pass then event is consumed by <strong>am_hsm_top()</strong>.</p>
<p>To inform the library that an event is handled the event handler function
must return <strong>AM_HSM_HANDLED()</strong>.
To inform the library that an event is passed to a superstate the event
handler function must return <strong>AM_HSM_SUPER(superstate)</strong>.</p>
</section>
<section id="state-transition">
<h2>State Transition<a class="headerlink" href="#state-transition" title="Link to this heading">¶</a></h2>
<p>When transitioning it is important to distinguish the current state and the
source state. They are not necessarily the same state. Consider the case when
the current state is C, an event is received by C and passed to the
superstate A, which decides to make a transition to the state F.  In this
case the current state is C, the source state is A and the target state is F.</p>
<p>When transitioning, exit events are sent up the ancestor chain until reaching
the nearest common ancestor (NCA) of the current and target states. Then,
entry events are sent down the ancestor chain to the target state. Finally
the library sends init event to the target state. The NCA does not receive
an exit event nor does it receive an entry and init events. There is a
special case when the source and target states match (a self-transition). In
this scenario the source state will be sent an exit and then an entry event
followed by the init event.</p>
<p>For example, if C is the current state and E is the target state, then the
NCA is state A. This means that exit events are sent to C
and B and then entry events are sent to D and E. Then the init event is sent
to E.</p>
<p>If B is the current state and F is the target state, then the NCA
is the default top level state am_hsm_top, so exit events are sent to B and A
and then an entry event is sent to F. Then the init event is sent to F.</p>
<p>If C is the current state and the target state, this exercises the special
case of a self-transition so C will be sent an exit event then an entry event
followed by the init event.</p>
<p>If C is the current state and the transition is initiated by A with the
target state A, then NCA is A, the exit events are sent to C,B,A and then the
entry event is sent to A followed by the init event.</p>
<p>If C is the current state and the transition is initiated by C with the
target state A, then NCA is A, the exit events are sent to C,B and then the
init event is sent to A. Please note that the state A is not exited in
this case.</p>
<p>To initiate a transition the state handler function must return
<strong>AM_HSM_TRAN(target_state)</strong> or <strong>AM_HSM_TRAN_REDISPATCH(target_state)</strong>.</p>
<p>If state handler function returns <strong>AM_HSM_TRAN_REDISPATCH(target_state)</strong>,
then the transition is executed first and then the same event is
dispatched to the new current state. This is a convenience feature,
that allows HSM to handle the event in the state that expects it.</p>
<p>HSM states cannot initiate state transitions when processing entry and exit
events.</p>
</section>
<section id="initial-state-transition">
<h2>Initial State Transition<a class="headerlink" href="#initial-state-transition" title="Link to this heading">¶</a></h2>
<p>If C is the current state and the transition is initiated by A with the
target state D, then NCA is A, the exit events are sent to C,B and then the
entry event is sent to D followed by the init event. The init event triggers
the initial state transition to E. So, the entry event is sent to E followed
by the init event.</p>
<p>The initial state transition must necessarily target a direct or transitive
substate of a given state. An initial transition cannot target a peer state
or go up in state hierarchy to higher-level states.</p>
<p>For example, the initial transition of state D can only target E and no any
other state.</p>
</section>
<section id="initial-state">
<h2>Initial State<a class="headerlink" href="#initial-state" title="Link to this heading">¶</a></h2>
<p>In addition to regular states every HSM must declare the initial state,
which the HSM library invokes to execute the topmost initial transition.</p>
</section>
<section id="hsm-initialization">
<h2>HSM Initialization<a class="headerlink" href="#hsm-initialization" title="Link to this heading">¶</a></h2>
<p>HSM initialization is divided into the following two steps for increased
flexibility and better control of the initialization timeline:</p>
<ol class="arabic simple">
<li><p>the state machine constructor (<strong>am_hsm_ctor()</strong>)</p></li>
<li><p>the top-most initial transition (<strong>am_hsm_init()</strong>).</p></li>
</ol>
</section>
<section id="hsm-topology">
<h2>HSM Topology<a class="headerlink" href="#hsm-topology" title="Link to this heading">¶</a></h2>
<p>HSM library discovers the user HSM topology by sending <strong>AM_EVT_HSM_EMPTY</strong> event
to state event handlers. The state event handlers should explicitly process
the event and always return <strong>AM_HSM_SUPER(superstate)</strong> in response.</p>
</section>
<section id="hsm-coding-rules">
<h2>HSM Coding Rules<a class="headerlink" href="#hsm-coding-rules" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>HSM states must be represented by event handlers of type <strong>am_hsm_state_fn</strong>.</p></li>
<li><p>The name of the first argument of all user event handler functions
must be <strong>me</strong>.</p></li>
<li><p>For convenience instead of using <strong>struct am_hsm *me</strong> the first argument
can point to a user structure. In this case the user structure
must have <strong>struct am_hsm</strong> instance as its first field.
For example, the first argument can be <strong>struct foo *me</strong>, where
<strong>struct foo</strong> is defined like this:</p></li>
</ol>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">am_hsm</span><span class="w"> </span><span class="n">hsm</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>Each user event handler should be implemented as a switch-case of handled
events.</p></li>
<li><p>Avoid placing any code with side effects outside of the switch-case of
event handlers.</p></li>
<li><p>Processing of <strong>AM_EVT_HSM_ENTRY</strong> and <strong>AM_EVT_HSM_EXIT</strong> events should
not trigger state transitions. It means that user event handlers should
not return <strong>AM_HSM_TRAN()</strong> or <strong>AM_HSM_TRAN_REDISPATCH()</strong> for
these events.</p></li>
<li><p>Processing of <strong>AM_EVT_HSM_INIT</strong> event can optionally only trigger
transition by returning the result of <strong>AM_HSM_TRAN()</strong> macro.
The use of <strong>AM_HSM_TRAN_REDISPATCH()</strong> is not allowed in this case.</p></li>
<li><p>Processing of <strong>AM_EVT_HSM_INIT</strong> event can optionally only trigger
transition to a substate of the state triggering the transition.
Transition to peer states of superstates is not allowed in this case.</p></li>
</ol>
</section>
<section id="transition-to-history">
<h2>Transition To History<a class="headerlink" href="#transition-to-history" title="Link to this heading">¶</a></h2>
<p>Transition to history is a useful technique that is convenient to apply in
certain use cases. It does not require to use any dedicated HSM API.</p>
<p>Given the example HSM above the transition to history technique can be
demonstrated as follows. Assume that the HSM is in the state B.
The user code stores the current state in a local variable of type
<strong>struct am_hsm_state</strong>. This is done with:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">am_hsm</span><span class="w"> </span><span class="n">hsm</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">am_hsm_state</span><span class="w"> </span><span class="n">history</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="k">static</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">am_hsm_rc</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="o">*</span><span class="n">me</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">AM_EVT_HSM_ENTRY</span><span class="p">:</span>
<span class="w">        </span><span class="n">me</span><span class="o">-&gt;</span><span class="n">history</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">am_hsm_get_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">hsm</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_HANDLED</span><span class="p">();</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_SUPER</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then the transition to state F happens, which is then followed by a request
to transition back to the previous state. Since the previous state is captured
in <strong>me-&gt;history</strong> it can be achieved by doing this:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">am_hsm_rc</span><span class="w"> </span><span class="nf">F</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="o">*</span><span class="n">me</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">HSM_EVT_FOO</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_TRAN</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">history</span><span class="p">.</span><span class="n">fn</span><span class="p">,</span><span class="w"> </span><span class="n">me</span><span class="o">-&gt;</span><span class="n">history</span><span class="p">.</span><span class="n">instance</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_SUPER</span><span class="p">(</span><span class="n">am_hsm_top</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>So, that is essentially all about it.</p>
<p>Another example of the usage of the transition to history technique can be seen
in <strong>tests/history.c</strong> unit test.</p>
</section>
<section id="submachines">
<h2>Submachines<a class="headerlink" href="#submachines" title="Link to this heading">¶</a></h2>
<p>Submachines are reusable HSMs. They can be as simple as one reusable state.
The more complex submachines can be multi state interconnected HSMs.</p>
<p>The main purpose of submachines is code reuse.</p>
<p>Here is an example of submachine with one reusable state s1.
It shows two instances of s1 called s1/0 and s1/1.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>     <span class="o">*</span>
<span class="o">+----|----------------------------------+</span>
<span class="o">|</span>    <span class="o">|</span>          <span class="n">am_hsm_top</span>              <span class="o">|</span>
<span class="o">|</span>    <span class="o">|</span> <span class="p">(</span><span class="n">HSM</span> <span class="n">top</span> <span class="n">superstate</span> <span class="n">am_hsm_top</span><span class="p">())</span><span class="o">|</span>
<span class="o">|</span>    <span class="o">|</span>                                  <span class="o">|</span>
<span class="o">|</span>  <span class="o">+-</span><span class="n">v</span><span class="o">-------------------------------+</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>               <span class="n">s</span>                 <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">+-----------+</span>  <span class="o">+------------+</span>  <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>    <span class="n">s1</span><span class="o">/</span><span class="mi">0</span>   <span class="o">|</span>  <span class="o">|</span>    <span class="n">s1</span><span class="o">/</span><span class="mi">1</span>    <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>   <span class="o">*</span>       <span class="o">|</span>  <span class="o">|</span>   <span class="o">*</span>        <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>   <span class="o">|</span>       <span class="o">|</span>  <span class="o">|</span>   <span class="o">|</span>        <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span> <span class="o">+-</span><span class="n">v</span><span class="o">-----+</span> <span class="o">|</span>  <span class="o">|</span> <span class="o">+-</span><span class="n">v</span><span class="o">------+</span> <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span> <span class="o">|</span>   <span class="n">s2</span>  <span class="o">|</span> <span class="o">|</span>  <span class="o">|</span> <span class="o">|</span>   <span class="n">s3</span>   <span class="o">|</span> <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span> <span class="o">+-------+</span> <span class="o">|</span>  <span class="o">|</span> <span class="o">+--------+</span> <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">+---^-------+</span>  <span class="o">+---^--------+</span>  <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">|</span>      <span class="o">|</span> <span class="n">FOO</span>          <span class="o">|</span> <span class="n">BAR</span>       <span class="o">|</span>  <span class="o">|</span>
<span class="o">|</span>  <span class="o">+------+-------^--+---+-----------+</span>  <span class="o">|</span>
<span class="o">|</span>                 <span class="o">|</span>  <span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span>                 <span class="o">+--+</span> <span class="n">BAZ</span>              <span class="o">|</span>
<span class="o">+---------------------------------------+</span>
</pre></div>
</div>
<p>Here is how it is coded in pseudocode:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/* s1 submachine instances */</span>
<span class="cp">#define S1_0 0</span>
<span class="cp">#define S1_1 1</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">sm</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">am_hsm</span><span class="w"> </span><span class="n">hsm</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">am_hsm_rc</span><span class="w"> </span><span class="nf">s</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sm</span><span class="w"> </span><span class="o">*</span><span class="n">me</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">FOO</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_TRAN</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="cm">/*instance=*/</span><span class="n">S1_0</span><span class="p">);</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">BAR</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_TRAN</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="cm">/*instance=*/</span><span class="n">S1_1</span><span class="p">);</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">BAZ</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_TRAN</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_SUPER</span><span class="p">(</span><span class="n">am_hsm_top</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">am_hsm_rc</span><span class="w"> </span><span class="nf">s1</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sm</span><span class="w"> </span><span class="o">*</span><span class="n">me</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">AM_EVT_HSM_INIT</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">am_hsm_state</span><span class="w"> </span><span class="n">tt</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="p">[</span><span class="n">S1_0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{.</span><span class="n">fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AM_HSM_STATE_FN_CTOR</span><span class="p">(</span><span class="n">s2</span><span class="p">)},</span>
<span class="w">            </span><span class="p">[</span><span class="n">S1_1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{.</span><span class="n">fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AM_HSM_STATE_FN_CTOR</span><span class="p">(</span><span class="n">s3</span><span class="p">)}</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">am_hsm_get_instance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">hsm</span><span class="p">);</span>
<span class="w">        </span><span class="n">AM_ASSERT</span><span class="p">(</span><span class="n">instance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">AM_COUNTOF</span><span class="p">(</span><span class="n">tt</span><span class="p">));</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_TRAN</span><span class="p">(</span><span class="n">tt</span><span class="p">[</span><span class="n">instance</span><span class="p">].</span><span class="n">fn</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_SUPER</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">am_hsm_rc</span><span class="w"> </span><span class="nf">s2</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sm</span><span class="w"> </span><span class="o">*</span><span class="n">me</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_SUPER</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">S1_0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">am_hsm_rc</span><span class="w"> </span><span class="nf">s3</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sm</span><span class="w"> </span><span class="o">*</span><span class="n">me</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">AM_HSM_SUPER</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">S1_1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Please note that any transitions between states within submachines as well as
all references to any submachine state via <strong>AM_HSM_SUPER()</strong>  must be done
with explicit specification of state instance, which can be retrieved by
calling <strong>am_hsm_get_instance()</strong> API.</p>
<p>The complete implementation of the given submachine example can be found
in <strong>tests/submachine/basic/test.c</strong></p>
<p>It is useful sometimes to instantiate a standalone submachine for the purpose
of unit testing, for example. To achieve this the transition tables outside of
the submachine must be extended with one more instance pointing to unit test
state(s). The extra instance then can be instantiated as a substate of
a unit test state machine(s).</p>
<p>A submachine (sub)state can also be a superstate of itself, which creates
a recursion. The example of the submachines recursion can be seen in
<strong>tests/submachine/complex/submachine.c</strong>.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  
    
  

  <h3>Contents</h3>
  <ul>
<li><a class="reference internal" href="#">Hierarchical State Machine (HSM)</a><ul>
<li><a class="reference internal" href="#credit">Credit</a></li>
<li><a class="reference internal" href="#glossary">Glossary</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#example-hsm">Example HSM</a></li>
<li><a class="reference internal" href="#state-relations">State Relations</a></li>
<li><a class="reference internal" href="#event-propagation">Event Propagation</a></li>
<li><a class="reference internal" href="#state-transition">State Transition</a></li>
<li><a class="reference internal" href="#initial-state-transition">Initial State Transition</a></li>
<li><a class="reference internal" href="#initial-state">Initial State</a></li>
<li><a class="reference internal" href="#hsm-initialization">HSM Initialization</a></li>
<li><a class="reference internal" href="#hsm-topology">HSM Topology</a></li>
<li><a class="reference internal" href="#hsm-coding-rules">HSM Coding Rules</a></li>
<li><a class="reference internal" href="#transition-to-history">Transition To History</a></li>
<li><a class="reference internal" href="#submachines">Submachines</a></li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul>
  <li><a href="index.html">Overview</a>
    <ul>
          <li>Previous: <a href="patterns/index.html" title="previous chapter">Patterns</a>
          <li>Next: <a href="fsm.html" title="next chapter">Finite State Machine (FSM)</a>
    </ul>
  </li>
</ul>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><div id="ethical-ad-placement"></div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2025, Adel Mamin.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>